{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n\nimport { computeNodePath } from '../../hierarchy';\nexport var computeNodes = function computeNodes(_ref) {\n  var root = _ref.root,\n      pack = _ref.pack,\n      leavesOnly = _ref.leavesOnly,\n      getIdentity = _ref.getIdentity,\n      getColor = _ref.getColor; // assign a unique id depending on node path to each node\n\n  root.each(function (node) {\n    node.id = getIdentity(node.data);\n    node.path = computeNodePath(node, getIdentity);\n  });\n  pack(root);\n  var nodes = leavesOnly ? root.leaves() : root.descendants();\n  nodes = nodes.map(function (node) {\n    node.color = getColor(_extends({}, node.data, {\n      depth: node.depth\n    }));\n    node.label = false;\n    return node;\n  });\n  return nodes;\n};\nexport var computeZoom = function computeZoom(nodes, currentNodePath, width, height) {\n  var currentNode = nodes.find(function (_ref2) {\n    var path = _ref2.path;\n    return path === currentNodePath;\n  });\n  if (!currentNode) return nodes;\n  var ratio = Math.min(width, height) / (currentNode.r * 2);\n  var offsetX = width / 2 - currentNode.x * ratio;\n  var offsetY = height / 2 - currentNode.y * ratio;\n  return nodes.map(function (node) {\n    return _extends({}, node, {\n      r: node.r * ratio,\n      x: node.x * ratio + offsetX,\n      y: node.y * ratio + offsetY\n    });\n  });\n};","map":{"version":3,"sources":["/Users/tom/Documents/MSE/zz_MasterThesis/06_FirmwareDroid/firmware-droid-client/node_modules/nivo/es/lib/charts/bubble/index.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","computeNodePath","computeNodes","_ref","root","pack","leavesOnly","getIdentity","getColor","each","node","id","data","path","nodes","leaves","descendants","map","color","depth","label","computeZoom","currentNodePath","width","height","currentNode","find","_ref2","ratio","Math","min","r","offsetX","x","offsetY","y"],"mappings":"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","sourcesContent":["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\n/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { computeNodePath } from '../../hierarchy';\n\nexport var computeNodes = function computeNodes(_ref) {\n    var root = _ref.root,\n        pack = _ref.pack,\n        leavesOnly = _ref.leavesOnly,\n        getIdentity = _ref.getIdentity,\n        getColor = _ref.getColor;\n\n    // assign a unique id depending on node path to each node\n    root.each(function (node) {\n        node.id = getIdentity(node.data);\n        node.path = computeNodePath(node, getIdentity);\n    });\n\n    pack(root);\n\n    var nodes = leavesOnly ? root.leaves() : root.descendants();\n    nodes = nodes.map(function (node) {\n        node.color = getColor(_extends({}, node.data, { depth: node.depth }));\n        node.label = false;\n\n        return node;\n    });\n\n    return nodes;\n};\n\nexport var computeZoom = function computeZoom(nodes, currentNodePath, width, height) {\n    var currentNode = nodes.find(function (_ref2) {\n        var path = _ref2.path;\n        return path === currentNodePath;\n    });\n\n    if (!currentNode) return nodes;\n\n    var ratio = Math.min(width, height) / (currentNode.r * 2);\n    var offsetX = width / 2 - currentNode.x * ratio;\n    var offsetY = height / 2 - currentNode.y * ratio;\n\n    return nodes.map(function (node) {\n        return _extends({}, node, {\n            r: node.r * ratio,\n            x: node.x * ratio + offsetX,\n            y: node.y * ratio + offsetY\n        });\n    });\n};"]},"metadata":{},"sourceType":"module"}