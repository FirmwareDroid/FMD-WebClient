{"ast":null,"code":"var __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n};\n\nimport React, { useCallback, useMemo, useState, useRef } from 'react';\nimport { cache } from './config';\n/*\nThe idea\n\nA \"Page\" component renders the content of 1 API request, it accepts an offset (in this example it's from),\nuses a SWR hook (useSWR(API + '?limit=' + limit + '&from=' + from)) and returns items (Projects).\n\nThe UI:\n      +------------------------------------------+\n      |   Projects                               |\n+------------------------------------------------------+\n|     |   +----------------+                     |     |\n|     |                                          |     |\n|     |   +------------+                         |     |\n|     |                                          |     +--> 1 Page\n|     |   +-----------------+                    |     |\n|     |                                          |     |  /projects/list?limit=4\n|     |   +---------+                            |     |\n+------------------------------------------------------+\n      |                                          |\n      |   +------------+                         |     +  /projects/list?limit=4&from=123\n      |                                          |     |\n      |   +----------------+                     |     |\n      |                                          |     |\n      |   +---------+                            |     |\n      |                                          |     |\n      |   +--------------+                       |     +\n      |                                          |\n      |   +-------------------+                  |     +  /projects/list?limit=4&from=456\n      |                                          |     |\n      |   +------------+                         |     |\n      |                                          |     |\n      |   +----------------+                     |     |\n      |                                          |     |\n      |                                          |     +\n\nThe API\n// (inside `render`)\n\nfunction App () {\n  const {\n    pages,    // an array of each page component\n    pageSWRs, // an array of SWRs of each page\n    isLoadingMore,\n    isReachingEnd,\n    isEmpty,\n    loadMore\n  } = useSWRPages(\n    'project-page', // key of this page\n\n    // ======== the actual Page component!\n    ({ offset, withSWR }) => {\n      // required: use `withSWR` to wrap your main SWR (source of your pagination API)\n      const { data } = withSWR(\n        useSWR(API + '?limit=10&from=' + offset) // request projects with offset\n      )\n      if (!data) return <Placeholder>\n      return data.projects.map(project => <Card project={project} team={team}>)\n    },\n    // ========\n\n    // a function accepts a SWR's `data`, and returns the offset of the next page (or null)\n    data => data && data.length >= 10 ? data[data.length - 1].createdAt : null,\n\n    // (optional) outside deps of your Page component. in this case it's empty\n    []\n  )\n\n  // ...\n\n  if (isEmpty) return <EmptyProjectsPage/>\n\n  return <div>\n    {pages}\n    {isReachingEnd\n      ? null\n      : <button loading={isLoadingMore} onClick={loadMore}>Load More</button>}\n  </div>\n}\n*/\n\nvar pageCacheMap = new Map();\nexport function useSWRPages(pageKey, pageFn, SWRToOffset, deps) {\n  if (deps === void 0) {\n    deps = [];\n  }\n\n  var pageCountKey = \"_swr_page_count_\" + pageKey;\n  var pageOffsetKey = \"_swr_page_offset_\" + pageKey;\n\n  var _a = useState(cache.get(pageCountKey) || 1),\n      pageCount = _a[0],\n      setPageCount = _a[1];\n\n  var _b = useState(cache.get(pageOffsetKey) || [null]),\n      pageOffsets = _b[0],\n      setPageOffsets = _b[1];\n\n  var _c = useState([]),\n      pageSWRs = _c[0],\n      setPageSWRs = _c[1];\n\n  var pageFnRef = useRef(pageFn);\n  var emptyPageRef = useRef(false); // Page component (wraps `pageFn`)\n  // for performance reason we need to memorize it\n\n  var Page = useCallback(function (props) {\n    // render the page component\n    var dataList = pageFnRef.current(props); // if dataList is [], we can assume this page is empty\n    // TODO: this API is not stable\n\n    if (dataList && !dataList.length) {\n      emptyPageRef.current = true;\n    } else {\n      emptyPageRef.current = false;\n    }\n\n    return dataList;\n  }, []); // Doesn't have a next page\n\n  var isReachingEnd = pageOffsets[pageCount] === null;\n  var isLoadingMore = pageCount === pageOffsets.length;\n  var isEmpty = isReachingEnd && pageCount === 1 && emptyPageRef.current;\n  var loadMore = useCallback(function () {\n    if (isLoadingMore || isReachingEnd) return;\n    setPageCount(function (c) {\n      cache.set(pageCountKey, c + 1);\n      return c + 1;\n    });\n  }, [isLoadingMore || isReachingEnd]);\n\n  var _pageFn = useCallback(pageFn, deps);\n\n  pageFnRef.current = _pageFn;\n  var pages = useMemo(function () {\n    var getWithSWR = function (id) {\n      return function (swr) {\n        if (!pageSWRs[id] || pageSWRs[id].data !== swr.data || pageSWRs[id].error !== swr.error || pageSWRs[id].revalidate !== swr.revalidate) {\n          // hoist side effects: setPageSWRs and setPageOffsets -- https://reactjs.org/blog/2020/02/26/react-v16.13.0.html#warnings-for-some-updates-during-render\n          setTimeout(function () {\n            setPageSWRs(function (swrs) {\n              var _swrs = __spreadArrays(swrs);\n\n              _swrs[id] = {\n                data: swr.data,\n                error: swr.error,\n                revalidate: swr.revalidate,\n                isValidating: swr.isValidating,\n                mutate: swr.mutate\n              };\n              return _swrs;\n            });\n\n            if (typeof swr.data !== 'undefined') {\n              // set next page's offset\n              var newPageOffset_1 = SWRToOffset(swr, id);\n\n              if (pageOffsets[id + 1] !== newPageOffset_1) {\n                setPageOffsets(function (arr) {\n                  var _arr = __spreadArrays(arr);\n\n                  _arr[id + 1] = newPageOffset_1;\n                  cache.set(pageOffsetKey, _arr);\n                  return _arr;\n                });\n              }\n            }\n          });\n        }\n\n        return swr;\n      };\n    }; // render each page\n\n\n    var p = [];\n\n    if (!pageCacheMap.has(pageKey)) {\n      pageCacheMap.set(pageKey, []);\n    }\n\n    var pageCache = pageCacheMap.get(pageKey);\n\n    for (var i = 0; i < pageCount; ++i) {\n      if (!pageCache[i] || pageCache[i].offset !== pageOffsets[i] || pageCache[i].pageFn !== _pageFn) {\n        // when props change or at init\n        // render the page and cache it\n        pageCache[i] = {\n          component: React.createElement(Page, {\n            key: \"page-\" + pageOffsets[i] + \"-\" + i,\n            offset: pageOffsets[i],\n            withSWR: getWithSWR(i)\n          }),\n          pageFn: _pageFn,\n          offset: pageOffsets[i]\n        };\n      }\n\n      p.push(pageCache[i].component);\n    }\n\n    return p;\n  }, [_pageFn, pageCount, pageSWRs, pageOffsets, pageKey]);\n  return {\n    pages: pages,\n    pageCount: pageCount,\n    pageSWRs: pageSWRs,\n    isLoadingMore: isLoadingMore,\n    isReachingEnd: isReachingEnd,\n    isEmpty: isEmpty,\n    loadMore: loadMore\n  };\n}","map":{"version":3,"sources":["/Users/tom/Documents/MSE/zz_MasterThesis/06_FirmwareDroid/firmware-droid-client/node_modules/swr/esm/use-swr-pages.js"],"names":["__spreadArrays","s","i","il","arguments","length","r","Array","k","a","j","jl","React","useCallback","useMemo","useState","useRef","cache","pageCacheMap","Map","useSWRPages","pageKey","pageFn","SWRToOffset","deps","pageCountKey","pageOffsetKey","_a","get","pageCount","setPageCount","_b","pageOffsets","setPageOffsets","_c","pageSWRs","setPageSWRs","pageFnRef","emptyPageRef","Page","props","dataList","current","isReachingEnd","isLoadingMore","isEmpty","loadMore","c","set","_pageFn","pages","getWithSWR","id","swr","data","error","revalidate","setTimeout","swrs","_swrs","isValidating","mutate","newPageOffset_1","arr","_arr","p","has","pageCache","offset","component","createElement","key","withSWR","push"],"mappings":"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","sourcesContent":["var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport React, { useCallback, useMemo, useState, useRef } from 'react';\nimport { cache } from './config';\n/*\nThe idea\n\nA \"Page\" component renders the content of 1 API request, it accepts an offset (in this example it's from),\nuses a SWR hook (useSWR(API + '?limit=' + limit + '&from=' + from)) and returns items (Projects).\n\nThe UI:\n      +------------------------------------------+\n      |   Projects                               |\n+------------------------------------------------------+\n|     |   +----------------+                     |     |\n|     |                                          |     |\n|     |   +------------+                         |     |\n|     |                                          |     +--> 1 Page\n|     |   +-----------------+                    |     |\n|     |                                          |     |  /projects/list?limit=4\n|     |   +---------+                            |     |\n+------------------------------------------------------+\n      |                                          |\n      |   +------------+                         |     +  /projects/list?limit=4&from=123\n      |                                          |     |\n      |   +----------------+                     |     |\n      |                                          |     |\n      |   +---------+                            |     |\n      |                                          |     |\n      |   +--------------+                       |     +\n      |                                          |\n      |   +-------------------+                  |     +  /projects/list?limit=4&from=456\n      |                                          |     |\n      |   +------------+                         |     |\n      |                                          |     |\n      |   +----------------+                     |     |\n      |                                          |     |\n      |                                          |     +\n\nThe API\n// (inside `render`)\n\nfunction App () {\n  const {\n    pages,    // an array of each page component\n    pageSWRs, // an array of SWRs of each page\n    isLoadingMore,\n    isReachingEnd,\n    isEmpty,\n    loadMore\n  } = useSWRPages(\n    'project-page', // key of this page\n\n    // ======== the actual Page component!\n    ({ offset, withSWR }) => {\n      // required: use `withSWR` to wrap your main SWR (source of your pagination API)\n      const { data } = withSWR(\n        useSWR(API + '?limit=10&from=' + offset) // request projects with offset\n      )\n      if (!data) return <Placeholder>\n      return data.projects.map(project => <Card project={project} team={team}>)\n    },\n    // ========\n\n    // a function accepts a SWR's `data`, and returns the offset of the next page (or null)\n    data => data && data.length >= 10 ? data[data.length - 1].createdAt : null,\n\n    // (optional) outside deps of your Page component. in this case it's empty\n    []\n  )\n\n  // ...\n\n  if (isEmpty) return <EmptyProjectsPage/>\n\n  return <div>\n    {pages}\n    {isReachingEnd\n      ? null\n      : <button loading={isLoadingMore} onClick={loadMore}>Load More</button>}\n  </div>\n}\n*/\nvar pageCacheMap = new Map();\nexport function useSWRPages(pageKey, pageFn, SWRToOffset, deps) {\n    if (deps === void 0) { deps = []; }\n    var pageCountKey = \"_swr_page_count_\" + pageKey;\n    var pageOffsetKey = \"_swr_page_offset_\" + pageKey;\n    var _a = useState(cache.get(pageCountKey) || 1), pageCount = _a[0], setPageCount = _a[1];\n    var _b = useState(cache.get(pageOffsetKey) || [null]), pageOffsets = _b[0], setPageOffsets = _b[1];\n    var _c = useState([]), pageSWRs = _c[0], setPageSWRs = _c[1];\n    var pageFnRef = useRef(pageFn);\n    var emptyPageRef = useRef(false);\n    // Page component (wraps `pageFn`)\n    // for performance reason we need to memorize it\n    var Page = useCallback(function (props) {\n        // render the page component\n        var dataList = pageFnRef.current(props);\n        // if dataList is [], we can assume this page is empty\n        // TODO: this API is not stable\n        if (dataList && !dataList.length) {\n            emptyPageRef.current = true;\n        }\n        else {\n            emptyPageRef.current = false;\n        }\n        return dataList;\n    }, []);\n    // Doesn't have a next page\n    var isReachingEnd = pageOffsets[pageCount] === null;\n    var isLoadingMore = pageCount === pageOffsets.length;\n    var isEmpty = isReachingEnd && pageCount === 1 && emptyPageRef.current;\n    var loadMore = useCallback(function () {\n        if (isLoadingMore || isReachingEnd)\n            return;\n        setPageCount(function (c) {\n            cache.set(pageCountKey, c + 1);\n            return c + 1;\n        });\n    }, [isLoadingMore || isReachingEnd]);\n    var _pageFn = useCallback(pageFn, deps);\n    pageFnRef.current = _pageFn;\n    var pages = useMemo(function () {\n        var getWithSWR = function (id) { return function (swr) {\n            if (!pageSWRs[id] ||\n                pageSWRs[id].data !== swr.data ||\n                pageSWRs[id].error !== swr.error ||\n                pageSWRs[id].revalidate !== swr.revalidate) {\n                // hoist side effects: setPageSWRs and setPageOffsets -- https://reactjs.org/blog/2020/02/26/react-v16.13.0.html#warnings-for-some-updates-during-render\n                setTimeout(function () {\n                    setPageSWRs(function (swrs) {\n                        var _swrs = __spreadArrays(swrs);\n                        _swrs[id] = {\n                            data: swr.data,\n                            error: swr.error,\n                            revalidate: swr.revalidate,\n                            isValidating: swr.isValidating,\n                            mutate: swr.mutate\n                        };\n                        return _swrs;\n                    });\n                    if (typeof swr.data !== 'undefined') {\n                        // set next page's offset\n                        var newPageOffset_1 = SWRToOffset(swr, id);\n                        if (pageOffsets[id + 1] !== newPageOffset_1) {\n                            setPageOffsets(function (arr) {\n                                var _arr = __spreadArrays(arr);\n                                _arr[id + 1] = newPageOffset_1;\n                                cache.set(pageOffsetKey, _arr);\n                                return _arr;\n                            });\n                        }\n                    }\n                });\n            }\n            return swr;\n        }; };\n        // render each page\n        var p = [];\n        if (!pageCacheMap.has(pageKey)) {\n            pageCacheMap.set(pageKey, []);\n        }\n        var pageCache = pageCacheMap.get(pageKey);\n        for (var i = 0; i < pageCount; ++i) {\n            if (!pageCache[i] ||\n                pageCache[i].offset !== pageOffsets[i] ||\n                pageCache[i].pageFn !== _pageFn) {\n                // when props change or at init\n                // render the page and cache it\n                pageCache[i] = {\n                    component: (React.createElement(Page, { key: \"page-\" + pageOffsets[i] + \"-\" + i, offset: pageOffsets[i], withSWR: getWithSWR(i) })),\n                    pageFn: _pageFn,\n                    offset: pageOffsets[i]\n                };\n            }\n            p.push(pageCache[i].component);\n        }\n        return p;\n    }, [_pageFn, pageCount, pageSWRs, pageOffsets, pageKey]);\n    return {\n        pages: pages,\n        pageCount: pageCount,\n        pageSWRs: pageSWRs,\n        isLoadingMore: isLoadingMore,\n        isReachingEnd: isReachingEnd,\n        isEmpty: isEmpty,\n        loadMore: loadMore\n    };\n}\n"]},"metadata":{},"sourceType":"module"}