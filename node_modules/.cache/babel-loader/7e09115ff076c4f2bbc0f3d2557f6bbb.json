{"ast":null,"code":"/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nvar isHoverTargetByType = {\n  cell: function cell(node, current) {\n    return node.xKey === current.xKey && node.yKey === current.yKey;\n  },\n  row: function row(node, current) {\n    return node.yKey === current.yKey;\n  },\n  column: function column(node, current) {\n    return node.xKey === current.xKey;\n  },\n  rowColumn: function rowColumn(node, current) {\n    return node.xKey === current.xKey || node.yKey === current.yKey;\n  }\n};\nexport var computeNodes = function computeNodes(_ref) {\n  var data = _ref.data,\n      keys = _ref.keys,\n      getIndex = _ref.getIndex,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      sizeScale = _ref.sizeScale,\n      cellOpacity = _ref.cellOpacity,\n      cellWidth = _ref.cellWidth,\n      cellHeight = _ref.cellHeight,\n      colorScale = _ref.colorScale,\n      getLabelTextColor = _ref.getLabelTextColor,\n      currentNode = _ref.currentNode,\n      hoverTarget = _ref.hoverTarget,\n      cellHoverOpacity = _ref.cellHoverOpacity,\n      cellHoverOthersOpacity = _ref.cellHoverOthersOpacity;\n  var isHoverTarget = isHoverTargetByType[hoverTarget];\n  return data.reduce(function (acc, d) {\n    keys.forEach(function (key) {\n      var width = sizeScale ? Math.min(sizeScale(d[key]) * cellWidth, cellWidth) : cellWidth;\n      var height = sizeScale ? Math.min(sizeScale(d[key]) * cellHeight, cellHeight) : cellHeight;\n      var node = {\n        key: key + \".\" + getIndex(d),\n        xKey: key,\n        yKey: getIndex(d),\n        x: xScale(key),\n        y: yScale(getIndex(d)),\n        width: width,\n        height: height,\n        value: d[key],\n        color: colorScale(d[key])\n      };\n      var opacity = cellOpacity;\n\n      if (currentNode) {\n        opacity = isHoverTarget(node, currentNode) ? cellHoverOpacity : cellHoverOthersOpacity;\n      }\n\n      acc.push(Object.assign(node, {\n        labelTextColor: getLabelTextColor(node),\n        opacity: opacity\n      }));\n    });\n    return acc;\n  }, []);\n};","map":{"version":3,"sources":["/Users/tom/Documents/MSE/zz_MasterThesis/06_FirmwareDroid/firmware-droid-client/node_modules/nivo/es/lib/charts/heatmap/index.js"],"names":["isHoverTargetByType","cell","node","current","xKey","yKey","row","column","rowColumn","computeNodes","_ref","data","keys","getIndex","xScale","yScale","sizeScale","cellOpacity","cellWidth","cellHeight","colorScale","getLabelTextColor","currentNode","hoverTarget","cellHoverOpacity","cellHoverOthersOpacity","isHoverTarget","reduce","acc","d","forEach","key","width","Math","min","height","x","y","value","color","opacity","push","Object","assign","labelTextColor"],"mappings":"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","sourcesContent":["/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nvar isHoverTargetByType = {\n    cell: function cell(node, current) {\n        return node.xKey === current.xKey && node.yKey === current.yKey;\n    },\n    row: function row(node, current) {\n        return node.yKey === current.yKey;\n    },\n    column: function column(node, current) {\n        return node.xKey === current.xKey;\n    },\n    rowColumn: function rowColumn(node, current) {\n        return node.xKey === current.xKey || node.yKey === current.yKey;\n    }\n};\n\nexport var computeNodes = function computeNodes(_ref) {\n    var data = _ref.data,\n        keys = _ref.keys,\n        getIndex = _ref.getIndex,\n        xScale = _ref.xScale,\n        yScale = _ref.yScale,\n        sizeScale = _ref.sizeScale,\n        cellOpacity = _ref.cellOpacity,\n        cellWidth = _ref.cellWidth,\n        cellHeight = _ref.cellHeight,\n        colorScale = _ref.colorScale,\n        getLabelTextColor = _ref.getLabelTextColor,\n        currentNode = _ref.currentNode,\n        hoverTarget = _ref.hoverTarget,\n        cellHoverOpacity = _ref.cellHoverOpacity,\n        cellHoverOthersOpacity = _ref.cellHoverOthersOpacity;\n\n    var isHoverTarget = isHoverTargetByType[hoverTarget];\n\n    return data.reduce(function (acc, d) {\n        keys.forEach(function (key) {\n            var width = sizeScale ? Math.min(sizeScale(d[key]) * cellWidth, cellWidth) : cellWidth;\n            var height = sizeScale ? Math.min(sizeScale(d[key]) * cellHeight, cellHeight) : cellHeight;\n\n            var node = {\n                key: key + \".\" + getIndex(d),\n                xKey: key,\n                yKey: getIndex(d),\n                x: xScale(key),\n                y: yScale(getIndex(d)),\n                width: width,\n                height: height,\n                value: d[key],\n                color: colorScale(d[key])\n            };\n\n            var opacity = cellOpacity;\n            if (currentNode) {\n                opacity = isHoverTarget(node, currentNode) ? cellHoverOpacity : cellHoverOthersOpacity;\n            }\n\n            acc.push(Object.assign(node, {\n                labelTextColor: getLabelTextColor(node),\n                opacity: opacity\n            }));\n        });\n\n        return acc;\n    }, []);\n};"]},"metadata":{},"sourceType":"module"}