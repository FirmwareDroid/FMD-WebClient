{"ast":null,"code":"import _max from 'lodash/max';\nimport _min from 'lodash/min';\nimport _flattenDepth from 'lodash/flattenDepth';\n/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { scaleLinear } from 'd3-scale';\nimport { stack, stackOffsetDiverging } from 'd3-shape';\nimport { getIndexedScale } from './common';\n/**\n * Generates scale for stacked bar chart.\n *\n * @param {Array.<Object>} data\n * @param {number|string}  _minValue\n * @param {number|string}  _maxValue\n * @param {Array.<number>} range\n * @returns {Function}\n */\n\nexport var getStackedScale = function getStackedScale(data, _minValue, _maxValue, range) {\n  var allValues = _flattenDepth(data, 2);\n\n  var minValue = _minValue;\n\n  if (minValue === 'auto') {\n    minValue = _min(allValues);\n  }\n\n  var maxValue = _maxValue;\n\n  if (maxValue === 'auto') {\n    maxValue = _max(allValues);\n  }\n\n  return scaleLinear().rangeRound(range).domain([minValue, maxValue]);\n};\n/**\n * Generates x/y scales & bars for vertical stacked bar chart.\n *\n * @param {Array.<Object>} data\n * @param {Function}       getIndex\n * @param {Array.<string>} keys\n * @param {number}         minValue\n * @param {number}         maxValue\n * @param {boolean}        reverse\n * @param {number}         width\n * @param {number}         height\n * @param {Function}       getColor\n * @param {number}         [padding=0]\n * @param {number}         [innerPadding=0]\n * @return {{ xScale: Function, yScale: Function, bars: Array.<Object> }}\n */\n\nexport var generateVerticalStackedBars = function generateVerticalStackedBars(_ref) {\n  var data = _ref.data,\n      getIndex = _ref.getIndex,\n      keys = _ref.keys,\n      minValue = _ref.minValue,\n      maxValue = _ref.maxValue,\n      reverse = _ref.reverse,\n      width = _ref.width,\n      height = _ref.height,\n      getColor = _ref.getColor,\n      _ref$padding = _ref.padding,\n      padding = _ref$padding === undefined ? 0 : _ref$padding,\n      _ref$innerPadding = _ref.innerPadding,\n      innerPadding = _ref$innerPadding === undefined ? 0 : _ref$innerPadding;\n  var stackedData = stack().keys(keys).offset(stackOffsetDiverging)(data);\n  var xScale = getIndexedScale(data, getIndex, [0, width], padding);\n  var yRange = reverse ? [0, height] : [height, 0];\n  var yScale = getStackedScale(stackedData, minValue, maxValue, yRange);\n  var bars = [];\n  var barWidth = xScale.bandwidth();\n\n  var getY = function getY(d) {\n    return yScale(d[1]);\n  };\n\n  var getHeight = function getHeight(d, y) {\n    return yScale(d[0]) - y;\n  };\n\n  if (reverse) {\n    getY = function getY(d) {\n      return yScale(d[0]);\n    };\n\n    getHeight = function getHeight(d, y) {\n      return yScale(d[1]) - y;\n    };\n  }\n\n  if (barWidth > 0) {\n    stackedData.forEach(function (stackedDataItem) {\n      xScale.domain().forEach(function (index, i) {\n        var d = stackedDataItem[i];\n        var x = xScale(getIndex(d.data));\n        var y = getY(d);\n        var barHeight = getHeight(d, y);\n\n        if (innerPadding > 0) {\n          y += innerPadding * 0.5;\n          barHeight -= innerPadding;\n        }\n\n        if (barHeight > 0) {\n          var barData = {\n            id: stackedDataItem.key,\n            value: d.data[stackedDataItem.key],\n            index: i,\n            indexValue: index,\n            data: d.data\n          };\n          bars.push({\n            key: stackedDataItem.key + '.' + index,\n            data: barData,\n            x: x,\n            y: y,\n            width: barWidth,\n            height: barHeight,\n            color: getColor(barData)\n          });\n        }\n      });\n    });\n  }\n\n  return {\n    xScale: xScale,\n    yScale: yScale,\n    bars: bars\n  };\n};\n/**\n * Generates x/y scales & bars for horizontal stacked bar chart.\n *\n * @param {Array.<Object>} data\n * @param {Function}       getIndex\n * @param {Array.<string>} keys\n * @param {number}         minValue\n * @param {number}         maxValue\n * @param {boolean}        reverse\n * @param {number}         width\n * @param {number}         height\n * @param {Function}       getColor\n * @param {number}         [padding=0]\n * @param {number}         [innerPadding=0]\n * @return {{ xScale: Function, yScale: Function, bars: Array.<Object> }}\n */\n\nexport var generateHorizontalStackedBars = function generateHorizontalStackedBars(_ref2) {\n  var data = _ref2.data,\n      getIndex = _ref2.getIndex,\n      keys = _ref2.keys,\n      minValue = _ref2.minValue,\n      maxValue = _ref2.maxValue,\n      reverse = _ref2.reverse,\n      width = _ref2.width,\n      height = _ref2.height,\n      getColor = _ref2.getColor,\n      _ref2$padding = _ref2.padding,\n      padding = _ref2$padding === undefined ? 0 : _ref2$padding,\n      _ref2$innerPadding = _ref2.innerPadding,\n      innerPadding = _ref2$innerPadding === undefined ? 0 : _ref2$innerPadding;\n  var stackedData = stack().keys(keys).offset(stackOffsetDiverging)(data);\n  var xRange = reverse ? [width, 0] : [0, width];\n  var xScale = getStackedScale(stackedData, minValue, maxValue, xRange);\n  var yScale = getIndexedScale(data, getIndex, [height, 0], padding);\n  var bars = [];\n  var barHeight = yScale.bandwidth();\n\n  var getX = function getX(d) {\n    return xScale(d[0]);\n  };\n\n  var getWidth = function getWidth(d, x) {\n    return xScale(d[1]) - x;\n  };\n\n  if (reverse) {\n    getX = function getX(d) {\n      return xScale(d[1]);\n    };\n\n    getWidth = function getWidth(d, y) {\n      return xScale(d[0]) - y;\n    };\n  }\n\n  if (barHeight > 0) {\n    stackedData.forEach(function (stackedDataItem) {\n      yScale.domain().forEach(function (index, i) {\n        var d = stackedDataItem[i];\n        var y = yScale(getIndex(d.data));\n        var barData = {\n          id: stackedDataItem.key,\n          value: d.data[stackedDataItem.key],\n          index: i,\n          indexValue: index,\n          data: d.data\n        };\n        var x = getX(d);\n        var barWidth = getWidth(d, x);\n\n        if (innerPadding > 0) {\n          x += innerPadding * 0.5;\n          barWidth -= innerPadding;\n        }\n\n        if (barWidth > 0) {\n          bars.push({\n            key: stackedDataItem.key + '.' + index,\n            data: barData,\n            x: x,\n            y: y,\n            width: barWidth,\n            height: barHeight,\n            color: getColor(barData)\n          });\n        }\n      });\n    });\n  }\n\n  return {\n    xScale: xScale,\n    yScale: yScale,\n    bars: bars\n  };\n};\n/**\n * Generates x/y scales & bars for stacked bar chart.\n *\n * @param {Object} options\n * @return {{ xScale: Function, yScale: Function, bars: Array.<Object> }}\n */\n\nexport var generateStackedBars = function generateStackedBars(options) {\n  return options.layout === 'vertical' ? generateVerticalStackedBars(options) : generateHorizontalStackedBars(options);\n};","map":{"version":3,"sources":["/Users/tom/Documents/MSE/zz_MasterThesis/06_FirmwareDroid/firmware-droid-client/node_modules/nivo/es/lib/charts/bar/stacked.js"],"names":["_max","_min","_flattenDepth","scaleLinear","stack","stackOffsetDiverging","getIndexedScale","getStackedScale","data","_minValue","_maxValue","range","allValues","minValue","maxValue","rangeRound","domain","generateVerticalStackedBars","_ref","getIndex","keys","reverse","width","height","getColor","_ref$padding","padding","undefined","_ref$innerPadding","innerPadding","stackedData","offset","xScale","yRange","yScale","bars","barWidth","bandwidth","getY","d","getHeight","y","forEach","stackedDataItem","index","i","x","barHeight","barData","id","key","value","indexValue","push","color","generateHorizontalStackedBars","_ref2","_ref2$padding","_ref2$innerPadding","xRange","getX","getWidth","generateStackedBars","options","layout"],"mappings":"AAAA,OAAOA,IAAP,MAAiB,YAAjB;AACA,OAAOC,IAAP,MAAiB,YAAjB;AACA,OAAOC,aAAP,MAA0B,qBAA1B;AAAiD;;;;;;;;;AASjD,SAASC,WAAT,QAA4B,UAA5B;AACA,SAASC,KAAT,EAAgBC,oBAAhB,QAA4C,UAA5C;AACA,SAASC,eAAT,QAAgC,UAAhC;AAEA;;;;;;;;;;AASA,OAAO,IAAIC,eAAe,GAAG,SAASA,eAAT,CAAyBC,IAAzB,EAA+BC,SAA/B,EAA0CC,SAA1C,EAAqDC,KAArD,EAA4D;AACrF,MAAIC,SAAS,GAAGV,aAAa,CAACM,IAAD,EAAO,CAAP,CAA7B;;AAEA,MAAIK,QAAQ,GAAGJ,SAAf;;AACA,MAAII,QAAQ,KAAK,MAAjB,EAAyB;AACrBA,IAAAA,QAAQ,GAAGZ,IAAI,CAACW,SAAD,CAAf;AACH;;AAED,MAAIE,QAAQ,GAAGJ,SAAf;;AACA,MAAII,QAAQ,KAAK,MAAjB,EAAyB;AACrBA,IAAAA,QAAQ,GAAGd,IAAI,CAACY,SAAD,CAAf;AACH;;AAED,SAAOT,WAAW,GAAGY,UAAd,CAAyBJ,KAAzB,EAAgCK,MAAhC,CAAuC,CAACH,QAAD,EAAWC,QAAX,CAAvC,CAAP;AACH,CAdM;AAgBP;;;;;;;;;;;;;;;;;AAgBA,OAAO,IAAIG,2BAA2B,GAAG,SAASA,2BAAT,CAAqCC,IAArC,EAA2C;AAChF,MAAIV,IAAI,GAAGU,IAAI,CAACV,IAAhB;AAAA,MACIW,QAAQ,GAAGD,IAAI,CAACC,QADpB;AAAA,MAEIC,IAAI,GAAGF,IAAI,CAACE,IAFhB;AAAA,MAGIP,QAAQ,GAAGK,IAAI,CAACL,QAHpB;AAAA,MAIIC,QAAQ,GAAGI,IAAI,CAACJ,QAJpB;AAAA,MAKIO,OAAO,GAAGH,IAAI,CAACG,OALnB;AAAA,MAMIC,KAAK,GAAGJ,IAAI,CAACI,KANjB;AAAA,MAOIC,MAAM,GAAGL,IAAI,CAACK,MAPlB;AAAA,MAQIC,QAAQ,GAAGN,IAAI,CAACM,QARpB;AAAA,MASIC,YAAY,GAAGP,IAAI,CAACQ,OATxB;AAAA,MAUIA,OAAO,GAAGD,YAAY,KAAKE,SAAjB,GAA6B,CAA7B,GAAiCF,YAV/C;AAAA,MAWIG,iBAAiB,GAAGV,IAAI,CAACW,YAX7B;AAAA,MAYIA,YAAY,GAAGD,iBAAiB,KAAKD,SAAtB,GAAkC,CAAlC,GAAsCC,iBAZzD;AAcA,MAAIE,WAAW,GAAG1B,KAAK,GAAGgB,IAAR,CAAaA,IAAb,EAAmBW,MAAnB,CAA0B1B,oBAA1B,EAAgDG,IAAhD,CAAlB;AAEA,MAAIwB,MAAM,GAAG1B,eAAe,CAACE,IAAD,EAAOW,QAAP,EAAiB,CAAC,CAAD,EAAIG,KAAJ,CAAjB,EAA6BI,OAA7B,CAA5B;AACA,MAAIO,MAAM,GAAGZ,OAAO,GAAG,CAAC,CAAD,EAAIE,MAAJ,CAAH,GAAiB,CAACA,MAAD,EAAS,CAAT,CAArC;AACA,MAAIW,MAAM,GAAG3B,eAAe,CAACuB,WAAD,EAAcjB,QAAd,EAAwBC,QAAxB,EAAkCmB,MAAlC,CAA5B;AAEA,MAAIE,IAAI,GAAG,EAAX;AACA,MAAIC,QAAQ,GAAGJ,MAAM,CAACK,SAAP,EAAf;;AAEA,MAAIC,IAAI,GAAG,SAASA,IAAT,CAAcC,CAAd,EAAiB;AACxB,WAAOL,MAAM,CAACK,CAAC,CAAC,CAAD,CAAF,CAAb;AACH,GAFD;;AAGA,MAAIC,SAAS,GAAG,SAASA,SAAT,CAAmBD,CAAnB,EAAsBE,CAAtB,EAAyB;AACrC,WAAOP,MAAM,CAACK,CAAC,CAAC,CAAD,CAAF,CAAN,GAAeE,CAAtB;AACH,GAFD;;AAGA,MAAIpB,OAAJ,EAAa;AACTiB,IAAAA,IAAI,GAAG,SAASA,IAAT,CAAcC,CAAd,EAAiB;AACpB,aAAOL,MAAM,CAACK,CAAC,CAAC,CAAD,CAAF,CAAb;AACH,KAFD;;AAGAC,IAAAA,SAAS,GAAG,SAASA,SAAT,CAAmBD,CAAnB,EAAsBE,CAAtB,EAAyB;AACjC,aAAOP,MAAM,CAACK,CAAC,CAAC,CAAD,CAAF,CAAN,GAAeE,CAAtB;AACH,KAFD;AAGH;;AAED,MAAIL,QAAQ,GAAG,CAAf,EAAkB;AACdN,IAAAA,WAAW,CAACY,OAAZ,CAAoB,UAAUC,eAAV,EAA2B;AAC3CX,MAAAA,MAAM,CAAChB,MAAP,GAAgB0B,OAAhB,CAAwB,UAAUE,KAAV,EAAiBC,CAAjB,EAAoB;AACxC,YAAIN,CAAC,GAAGI,eAAe,CAACE,CAAD,CAAvB;AACA,YAAIC,CAAC,GAAGd,MAAM,CAACb,QAAQ,CAACoB,CAAC,CAAC/B,IAAH,CAAT,CAAd;AAEA,YAAIiC,CAAC,GAAGH,IAAI,CAACC,CAAD,CAAZ;AACA,YAAIQ,SAAS,GAAGP,SAAS,CAACD,CAAD,EAAIE,CAAJ,CAAzB;;AACA,YAAIZ,YAAY,GAAG,CAAnB,EAAsB;AAClBY,UAAAA,CAAC,IAAIZ,YAAY,GAAG,GAApB;AACAkB,UAAAA,SAAS,IAAIlB,YAAb;AACH;;AAED,YAAIkB,SAAS,GAAG,CAAhB,EAAmB;AACf,cAAIC,OAAO,GAAG;AACVC,YAAAA,EAAE,EAAEN,eAAe,CAACO,GADV;AAEVC,YAAAA,KAAK,EAAEZ,CAAC,CAAC/B,IAAF,CAAOmC,eAAe,CAACO,GAAvB,CAFG;AAGVN,YAAAA,KAAK,EAAEC,CAHG;AAIVO,YAAAA,UAAU,EAAER,KAJF;AAKVpC,YAAAA,IAAI,EAAE+B,CAAC,CAAC/B;AALE,WAAd;AAQA2B,UAAAA,IAAI,CAACkB,IAAL,CAAU;AACNH,YAAAA,GAAG,EAAEP,eAAe,CAACO,GAAhB,GAAsB,GAAtB,GAA4BN,KAD3B;AAENpC,YAAAA,IAAI,EAAEwC,OAFA;AAGNF,YAAAA,CAAC,EAAEA,CAHG;AAINL,YAAAA,CAAC,EAAEA,CAJG;AAKNnB,YAAAA,KAAK,EAAEc,QALD;AAMNb,YAAAA,MAAM,EAAEwB,SANF;AAONO,YAAAA,KAAK,EAAE9B,QAAQ,CAACwB,OAAD;AAPT,WAAV;AASH;AACJ,OA9BD;AA+BH,KAhCD;AAiCH;;AAED,SAAO;AAAEhB,IAAAA,MAAM,EAAEA,MAAV;AAAkBE,IAAAA,MAAM,EAAEA,MAA1B;AAAkCC,IAAAA,IAAI,EAAEA;AAAxC,GAAP;AACH,CA5EM;AA8EP;;;;;;;;;;;;;;;;;AAgBA,OAAO,IAAIoB,6BAA6B,GAAG,SAASA,6BAAT,CAAuCC,KAAvC,EAA8C;AACrF,MAAIhD,IAAI,GAAGgD,KAAK,CAAChD,IAAjB;AAAA,MACIW,QAAQ,GAAGqC,KAAK,CAACrC,QADrB;AAAA,MAEIC,IAAI,GAAGoC,KAAK,CAACpC,IAFjB;AAAA,MAGIP,QAAQ,GAAG2C,KAAK,CAAC3C,QAHrB;AAAA,MAIIC,QAAQ,GAAG0C,KAAK,CAAC1C,QAJrB;AAAA,MAKIO,OAAO,GAAGmC,KAAK,CAACnC,OALpB;AAAA,MAMIC,KAAK,GAAGkC,KAAK,CAAClC,KANlB;AAAA,MAOIC,MAAM,GAAGiC,KAAK,CAACjC,MAPnB;AAAA,MAQIC,QAAQ,GAAGgC,KAAK,CAAChC,QARrB;AAAA,MASIiC,aAAa,GAAGD,KAAK,CAAC9B,OAT1B;AAAA,MAUIA,OAAO,GAAG+B,aAAa,KAAK9B,SAAlB,GAA8B,CAA9B,GAAkC8B,aAVhD;AAAA,MAWIC,kBAAkB,GAAGF,KAAK,CAAC3B,YAX/B;AAAA,MAYIA,YAAY,GAAG6B,kBAAkB,KAAK/B,SAAvB,GAAmC,CAAnC,GAAuC+B,kBAZ1D;AAcA,MAAI5B,WAAW,GAAG1B,KAAK,GAAGgB,IAAR,CAAaA,IAAb,EAAmBW,MAAnB,CAA0B1B,oBAA1B,EAAgDG,IAAhD,CAAlB;AAEA,MAAImD,MAAM,GAAGtC,OAAO,GAAG,CAACC,KAAD,EAAQ,CAAR,CAAH,GAAgB,CAAC,CAAD,EAAIA,KAAJ,CAApC;AACA,MAAIU,MAAM,GAAGzB,eAAe,CAACuB,WAAD,EAAcjB,QAAd,EAAwBC,QAAxB,EAAkC6C,MAAlC,CAA5B;AACA,MAAIzB,MAAM,GAAG5B,eAAe,CAACE,IAAD,EAAOW,QAAP,EAAiB,CAACI,MAAD,EAAS,CAAT,CAAjB,EAA8BG,OAA9B,CAA5B;AAEA,MAAIS,IAAI,GAAG,EAAX;AACA,MAAIY,SAAS,GAAGb,MAAM,CAACG,SAAP,EAAhB;;AAEA,MAAIuB,IAAI,GAAG,SAASA,IAAT,CAAcrB,CAAd,EAAiB;AACxB,WAAOP,MAAM,CAACO,CAAC,CAAC,CAAD,CAAF,CAAb;AACH,GAFD;;AAGA,MAAIsB,QAAQ,GAAG,SAASA,QAAT,CAAkBtB,CAAlB,EAAqBO,CAArB,EAAwB;AACnC,WAAOd,MAAM,CAACO,CAAC,CAAC,CAAD,CAAF,CAAN,GAAeO,CAAtB;AACH,GAFD;;AAGA,MAAIzB,OAAJ,EAAa;AACTuC,IAAAA,IAAI,GAAG,SAASA,IAAT,CAAcrB,CAAd,EAAiB;AACpB,aAAOP,MAAM,CAACO,CAAC,CAAC,CAAD,CAAF,CAAb;AACH,KAFD;;AAGAsB,IAAAA,QAAQ,GAAG,SAASA,QAAT,CAAkBtB,CAAlB,EAAqBE,CAArB,EAAwB;AAC/B,aAAOT,MAAM,CAACO,CAAC,CAAC,CAAD,CAAF,CAAN,GAAeE,CAAtB;AACH,KAFD;AAGH;;AAED,MAAIM,SAAS,GAAG,CAAhB,EAAmB;AACfjB,IAAAA,WAAW,CAACY,OAAZ,CAAoB,UAAUC,eAAV,EAA2B;AAC3CT,MAAAA,MAAM,CAAClB,MAAP,GAAgB0B,OAAhB,CAAwB,UAAUE,KAAV,EAAiBC,CAAjB,EAAoB;AACxC,YAAIN,CAAC,GAAGI,eAAe,CAACE,CAAD,CAAvB;AACA,YAAIJ,CAAC,GAAGP,MAAM,CAACf,QAAQ,CAACoB,CAAC,CAAC/B,IAAH,CAAT,CAAd;AAEA,YAAIwC,OAAO,GAAG;AACVC,UAAAA,EAAE,EAAEN,eAAe,CAACO,GADV;AAEVC,UAAAA,KAAK,EAAEZ,CAAC,CAAC/B,IAAF,CAAOmC,eAAe,CAACO,GAAvB,CAFG;AAGVN,UAAAA,KAAK,EAAEC,CAHG;AAIVO,UAAAA,UAAU,EAAER,KAJF;AAKVpC,UAAAA,IAAI,EAAE+B,CAAC,CAAC/B;AALE,SAAd;AAQA,YAAIsC,CAAC,GAAGc,IAAI,CAACrB,CAAD,CAAZ;AACA,YAAIH,QAAQ,GAAGyB,QAAQ,CAACtB,CAAD,EAAIO,CAAJ,CAAvB;;AACA,YAAIjB,YAAY,GAAG,CAAnB,EAAsB;AAClBiB,UAAAA,CAAC,IAAIjB,YAAY,GAAG,GAApB;AACAO,UAAAA,QAAQ,IAAIP,YAAZ;AACH;;AAED,YAAIO,QAAQ,GAAG,CAAf,EAAkB;AACdD,UAAAA,IAAI,CAACkB,IAAL,CAAU;AACNH,YAAAA,GAAG,EAAEP,eAAe,CAACO,GAAhB,GAAsB,GAAtB,GAA4BN,KAD3B;AAENpC,YAAAA,IAAI,EAAEwC,OAFA;AAGNF,YAAAA,CAAC,EAAEA,CAHG;AAINL,YAAAA,CAAC,EAAEA,CAJG;AAKNnB,YAAAA,KAAK,EAAEc,QALD;AAMNb,YAAAA,MAAM,EAAEwB,SANF;AAONO,YAAAA,KAAK,EAAE9B,QAAQ,CAACwB,OAAD;AAPT,WAAV;AASH;AACJ,OA9BD;AA+BH,KAhCD;AAiCH;;AAED,SAAO;AAAEhB,IAAAA,MAAM,EAAEA,MAAV;AAAkBE,IAAAA,MAAM,EAAEA,MAA1B;AAAkCC,IAAAA,IAAI,EAAEA;AAAxC,GAAP;AACH,CA5EM;AA8EP;;;;;;;AAMA,OAAO,IAAI2B,mBAAmB,GAAG,SAASA,mBAAT,CAA6BC,OAA7B,EAAsC;AACnE,SAAOA,OAAO,CAACC,MAAR,KAAmB,UAAnB,GAAgC/C,2BAA2B,CAAC8C,OAAD,CAA3D,GAAuER,6BAA6B,CAACQ,OAAD,CAA3G;AACH,CAFM","sourcesContent":["import _max from 'lodash/max';\nimport _min from 'lodash/min';\nimport _flattenDepth from 'lodash/flattenDepth'; /*\n                                                  * This file is part of the nivo project.\n                                                  *\n                                                  * Copyright 2016-present, Raphaël Benitte.\n                                                  *\n                                                  * For the full copyright and license information, please view the LICENSE\n                                                  * file that was distributed with this source code.\n                                                  */\n\nimport { scaleLinear } from 'd3-scale';\nimport { stack, stackOffsetDiverging } from 'd3-shape';\nimport { getIndexedScale } from './common';\n\n/**\n * Generates scale for stacked bar chart.\n *\n * @param {Array.<Object>} data\n * @param {number|string}  _minValue\n * @param {number|string}  _maxValue\n * @param {Array.<number>} range\n * @returns {Function}\n */\nexport var getStackedScale = function getStackedScale(data, _minValue, _maxValue, range) {\n    var allValues = _flattenDepth(data, 2);\n\n    var minValue = _minValue;\n    if (minValue === 'auto') {\n        minValue = _min(allValues);\n    }\n\n    var maxValue = _maxValue;\n    if (maxValue === 'auto') {\n        maxValue = _max(allValues);\n    }\n\n    return scaleLinear().rangeRound(range).domain([minValue, maxValue]);\n};\n\n/**\n * Generates x/y scales & bars for vertical stacked bar chart.\n *\n * @param {Array.<Object>} data\n * @param {Function}       getIndex\n * @param {Array.<string>} keys\n * @param {number}         minValue\n * @param {number}         maxValue\n * @param {boolean}        reverse\n * @param {number}         width\n * @param {number}         height\n * @param {Function}       getColor\n * @param {number}         [padding=0]\n * @param {number}         [innerPadding=0]\n * @return {{ xScale: Function, yScale: Function, bars: Array.<Object> }}\n */\nexport var generateVerticalStackedBars = function generateVerticalStackedBars(_ref) {\n    var data = _ref.data,\n        getIndex = _ref.getIndex,\n        keys = _ref.keys,\n        minValue = _ref.minValue,\n        maxValue = _ref.maxValue,\n        reverse = _ref.reverse,\n        width = _ref.width,\n        height = _ref.height,\n        getColor = _ref.getColor,\n        _ref$padding = _ref.padding,\n        padding = _ref$padding === undefined ? 0 : _ref$padding,\n        _ref$innerPadding = _ref.innerPadding,\n        innerPadding = _ref$innerPadding === undefined ? 0 : _ref$innerPadding;\n\n    var stackedData = stack().keys(keys).offset(stackOffsetDiverging)(data);\n\n    var xScale = getIndexedScale(data, getIndex, [0, width], padding);\n    var yRange = reverse ? [0, height] : [height, 0];\n    var yScale = getStackedScale(stackedData, minValue, maxValue, yRange);\n\n    var bars = [];\n    var barWidth = xScale.bandwidth();\n\n    var getY = function getY(d) {\n        return yScale(d[1]);\n    };\n    var getHeight = function getHeight(d, y) {\n        return yScale(d[0]) - y;\n    };\n    if (reverse) {\n        getY = function getY(d) {\n            return yScale(d[0]);\n        };\n        getHeight = function getHeight(d, y) {\n            return yScale(d[1]) - y;\n        };\n    }\n\n    if (barWidth > 0) {\n        stackedData.forEach(function (stackedDataItem) {\n            xScale.domain().forEach(function (index, i) {\n                var d = stackedDataItem[i];\n                var x = xScale(getIndex(d.data));\n\n                var y = getY(d);\n                var barHeight = getHeight(d, y);\n                if (innerPadding > 0) {\n                    y += innerPadding * 0.5;\n                    barHeight -= innerPadding;\n                }\n\n                if (barHeight > 0) {\n                    var barData = {\n                        id: stackedDataItem.key,\n                        value: d.data[stackedDataItem.key],\n                        index: i,\n                        indexValue: index,\n                        data: d.data\n                    };\n\n                    bars.push({\n                        key: stackedDataItem.key + '.' + index,\n                        data: barData,\n                        x: x,\n                        y: y,\n                        width: barWidth,\n                        height: barHeight,\n                        color: getColor(barData)\n                    });\n                }\n            });\n        });\n    }\n\n    return { xScale: xScale, yScale: yScale, bars: bars };\n};\n\n/**\n * Generates x/y scales & bars for horizontal stacked bar chart.\n *\n * @param {Array.<Object>} data\n * @param {Function}       getIndex\n * @param {Array.<string>} keys\n * @param {number}         minValue\n * @param {number}         maxValue\n * @param {boolean}        reverse\n * @param {number}         width\n * @param {number}         height\n * @param {Function}       getColor\n * @param {number}         [padding=0]\n * @param {number}         [innerPadding=0]\n * @return {{ xScale: Function, yScale: Function, bars: Array.<Object> }}\n */\nexport var generateHorizontalStackedBars = function generateHorizontalStackedBars(_ref2) {\n    var data = _ref2.data,\n        getIndex = _ref2.getIndex,\n        keys = _ref2.keys,\n        minValue = _ref2.minValue,\n        maxValue = _ref2.maxValue,\n        reverse = _ref2.reverse,\n        width = _ref2.width,\n        height = _ref2.height,\n        getColor = _ref2.getColor,\n        _ref2$padding = _ref2.padding,\n        padding = _ref2$padding === undefined ? 0 : _ref2$padding,\n        _ref2$innerPadding = _ref2.innerPadding,\n        innerPadding = _ref2$innerPadding === undefined ? 0 : _ref2$innerPadding;\n\n    var stackedData = stack().keys(keys).offset(stackOffsetDiverging)(data);\n\n    var xRange = reverse ? [width, 0] : [0, width];\n    var xScale = getStackedScale(stackedData, minValue, maxValue, xRange);\n    var yScale = getIndexedScale(data, getIndex, [height, 0], padding);\n\n    var bars = [];\n    var barHeight = yScale.bandwidth();\n\n    var getX = function getX(d) {\n        return xScale(d[0]);\n    };\n    var getWidth = function getWidth(d, x) {\n        return xScale(d[1]) - x;\n    };\n    if (reverse) {\n        getX = function getX(d) {\n            return xScale(d[1]);\n        };\n        getWidth = function getWidth(d, y) {\n            return xScale(d[0]) - y;\n        };\n    }\n\n    if (barHeight > 0) {\n        stackedData.forEach(function (stackedDataItem) {\n            yScale.domain().forEach(function (index, i) {\n                var d = stackedDataItem[i];\n                var y = yScale(getIndex(d.data));\n\n                var barData = {\n                    id: stackedDataItem.key,\n                    value: d.data[stackedDataItem.key],\n                    index: i,\n                    indexValue: index,\n                    data: d.data\n                };\n\n                var x = getX(d);\n                var barWidth = getWidth(d, x);\n                if (innerPadding > 0) {\n                    x += innerPadding * 0.5;\n                    barWidth -= innerPadding;\n                }\n\n                if (barWidth > 0) {\n                    bars.push({\n                        key: stackedDataItem.key + '.' + index,\n                        data: barData,\n                        x: x,\n                        y: y,\n                        width: barWidth,\n                        height: barHeight,\n                        color: getColor(barData)\n                    });\n                }\n            });\n        });\n    }\n\n    return { xScale: xScale, yScale: yScale, bars: bars };\n};\n\n/**\n * Generates x/y scales & bars for stacked bar chart.\n *\n * @param {Object} options\n * @return {{ xScale: Function, yScale: Function, bars: Array.<Object> }}\n */\nexport var generateStackedBars = function generateStackedBars(options) {\n    return options.layout === 'vertical' ? generateVerticalStackedBars(options) : generateHorizontalStackedBars(options);\n};"]},"metadata":{},"sourceType":"module"}