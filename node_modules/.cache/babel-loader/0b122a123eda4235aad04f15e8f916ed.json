{"ast":null,"code":"import _max from 'lodash/max';\nimport _min from 'lodash/min';\nimport _range from 'lodash/range';\n/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, RaphaÃ«l Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { scaleLinear } from 'd3-scale';\nimport { getIndexedScale } from './common';\n/**\n * Generates scale for grouped bar chart.\n *\n * @param {Array.<Object>} data\n * @param {Array.<string>} keys\n * @param {number}         _minValue\n * @param {number|string}  _maxValue\n * @param {Array.<number>} range\n * @returns {Function}\n */\n\nexport var getGroupedScale = function getGroupedScale(data, keys, _minValue, _maxValue, range) {\n  var allValues = data.reduce(function (acc, entry) {\n    return [].concat(acc, keys.map(function (k) {\n      return entry[k];\n    }));\n  }, []);\n  var maxValue = _maxValue;\n\n  if (maxValue === 'auto') {\n    maxValue = _max(allValues);\n  }\n\n  var minValue = _minValue;\n\n  if (minValue === 'auto') {\n    minValue = _min(allValues);\n    if (minValue > 0) minValue = 0;\n  }\n\n  return scaleLinear().rangeRound(range).domain([minValue, maxValue]);\n};\n/**\n * Generates x/y scales & bars for vertical grouped bar chart.\n *\n * @param {Array.<Object>} data\n * @param {Function}       getIndex\n * @param {Array.<string>} keys\n * @param {number}         minValue\n * @param {number}         maxValue\n * @param {boolean}        reverse\n * @param {number}         width\n * @param {number}         height\n * @param {Function}       getColor\n * @param {number}         [padding=0]\n * @param {number}         [innerPadding=0]\n * @return {{ xScale: Function, yScale: Function, bars: Array.<Object> }}\n */\n\nexport var generateVerticalGroupedBars = function generateVerticalGroupedBars(_ref) {\n  var data = _ref.data,\n      getIndex = _ref.getIndex,\n      keys = _ref.keys,\n      minValue = _ref.minValue,\n      maxValue = _ref.maxValue,\n      reverse = _ref.reverse,\n      width = _ref.width,\n      height = _ref.height,\n      getColor = _ref.getColor,\n      _ref$padding = _ref.padding,\n      padding = _ref$padding === undefined ? 0 : _ref$padding,\n      _ref$innerPadding = _ref.innerPadding,\n      innerPadding = _ref$innerPadding === undefined ? 0 : _ref$innerPadding;\n  var xScale = getIndexedScale(data, getIndex, [0, width], padding);\n  var yRange = reverse ? [0, height] : [height, 0];\n  var yScale = getGroupedScale(data, keys, minValue, maxValue, yRange);\n  var barWidth = (xScale.bandwidth() - innerPadding * (keys.length - 1)) / keys.length;\n  var yRef = yScale(0);\n\n  var getY = function getY(d) {\n    return d > 0 ? yScale(d) : yRef;\n  };\n\n  var getHeight = function getHeight(d, y) {\n    return d > 0 ? yRef - y : yScale(d) - yRef;\n  };\n\n  if (reverse) {\n    getY = function getY(d) {\n      return d < 0 ? yScale(d) : yRef;\n    };\n\n    getHeight = function getHeight(d, y) {\n      return d < 0 ? yRef - y : yScale(d) - yRef;\n    };\n  }\n\n  var bars = [];\n\n  if (barWidth > 0) {\n    keys.forEach(function (key, i) {\n      _range(xScale.domain().length).forEach(function (index) {\n        var x = xScale(getIndex(data[index])) + barWidth * i + innerPadding * i;\n        var y = getY(data[index][key]);\n        var barHeight = getHeight(data[index][key], y);\n\n        if (barWidth > 0 && barHeight > 0) {\n          var barData = {\n            id: key,\n            value: data[index][key],\n            index: index,\n            indexValue: getIndex(data[index]),\n            data: data[index]\n          };\n          bars.push({\n            key: key + '.' + barData.indexValue,\n            data: barData,\n            x: x,\n            y: y,\n            width: barWidth,\n            height: barHeight,\n            color: getColor(barData)\n          });\n        }\n      });\n    });\n  }\n\n  return {\n    xScale: xScale,\n    yScale: yScale,\n    bars: bars\n  };\n};\n/**\n * Generates x/y scales & bars for horizontal grouped bar chart.\n *\n * @param {Array.<Object>} data\n * @param {Function}       getIndex\n * @param {Array.<string>} keys\n * @param {number}         minValue\n * @param {number}         maxValue\n * @param {boolean}        reverse\n * @param {number}         width\n * @param {number}         height\n * @param {Function}       getColor\n * @param {number}         [padding=0]\n * @param {number}         [innerPadding=0]\n * @return {{ xScale: Function, yScale: Function, bars: Array.<Object> }}\n */\n\nexport var generateHorizontalGroupedBars = function generateHorizontalGroupedBars(_ref2) {\n  var data = _ref2.data,\n      getIndex = _ref2.getIndex,\n      keys = _ref2.keys,\n      minValue = _ref2.minValue,\n      maxValue = _ref2.maxValue,\n      reverse = _ref2.reverse,\n      width = _ref2.width,\n      height = _ref2.height,\n      getColor = _ref2.getColor,\n      _ref2$padding = _ref2.padding,\n      padding = _ref2$padding === undefined ? 0 : _ref2$padding,\n      _ref2$innerPadding = _ref2.innerPadding,\n      innerPadding = _ref2$innerPadding === undefined ? 0 : _ref2$innerPadding;\n  var xRange = reverse ? [width, 0] : [0, width];\n  var xScale = getGroupedScale(data, keys, minValue, maxValue, xRange);\n  var yScale = getIndexedScale(data, getIndex, [height, 0], padding);\n  var barHeight = (yScale.bandwidth() - innerPadding * (keys.length - 1)) / keys.length;\n  var xRef = xScale(0);\n\n  var getX = function getX(d) {\n    return d > 0 ? xRef : xScale(d);\n  };\n\n  var getWidth = function getWidth(d, x) {\n    return d > 0 ? xScale(d) - xRef : xRef - x;\n  };\n\n  if (reverse) {\n    getX = function getX(d) {\n      return d < 0 ? xRef : xScale(d);\n    };\n\n    getWidth = function getWidth(d, x) {\n      return d < 0 ? xScale(d) - xRef : xRef - x;\n    };\n  }\n\n  var bars = [];\n\n  if (barHeight > 0) {\n    keys.forEach(function (key, i) {\n      _range(yScale.domain().length).forEach(function (index) {\n        var x = getX(data[index][key]);\n        var y = yScale(getIndex(data[index])) + barHeight * i + innerPadding * i;\n        var barWidth = getWidth(data[index][key], x);\n\n        if (barWidth > 0) {\n          var barData = {\n            id: key,\n            value: data[index][key],\n            index: index,\n            indexValue: getIndex(data[index]),\n            data: data[index]\n          };\n          bars.push({\n            key: key + '.' + barData.indexValue,\n            data: barData,\n            x: x,\n            y: y,\n            width: barWidth,\n            height: barHeight,\n            color: getColor(barData)\n          });\n        }\n      });\n    });\n  }\n\n  return {\n    xScale: xScale,\n    yScale: yScale,\n    bars: bars\n  };\n};\n/**\n * Generates x/y scales & bars for grouped bar chart.\n *\n * @param {Object} options\n * @return {{ xScale: Function, yScale: Function, bars: Array.<Object> }}\n */\n\nexport var generateGroupedBars = function generateGroupedBars(options) {\n  return options.layout === 'vertical' ? generateVerticalGroupedBars(options) : generateHorizontalGroupedBars(options);\n};","map":{"version":3,"sources":["/Users/tom/Documents/MSE/zz_MasterThesis/06_FirmwareDroid/firmware-droid-client/node_modules/nivo/es/lib/charts/bar/grouped.js"],"names":["_max","_min","_range","scaleLinear","getIndexedScale","getGroupedScale","data","keys","_minValue","_maxValue","range","allValues","reduce","acc","entry","concat","map","k","maxValue","minValue","rangeRound","domain","generateVerticalGroupedBars","_ref","getIndex","reverse","width","height","getColor","_ref$padding","padding","undefined","_ref$innerPadding","innerPadding","xScale","yRange","yScale","barWidth","bandwidth","length","yRef","getY","d","getHeight","y","bars","forEach","key","i","index","x","barHeight","barData","id","value","indexValue","push","color","generateHorizontalGroupedBars","_ref2","_ref2$padding","_ref2$innerPadding","xRange","xRef","getX","getWidth","generateGroupedBars","options","layout"],"mappings":"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","sourcesContent":["import _max from 'lodash/max';\nimport _min from 'lodash/min';\nimport _range from 'lodash/range'; /*\n                                    * This file is part of the nivo project.\n                                    *\n                                    * Copyright 2016-present, RaphaÃ«l Benitte.\n                                    *\n                                    * For the full copyright and license information, please view the LICENSE\n                                    * file that was distributed with this source code.\n                                    */\n\nimport { scaleLinear } from 'd3-scale';\nimport { getIndexedScale } from './common';\n\n/**\n * Generates scale for grouped bar chart.\n *\n * @param {Array.<Object>} data\n * @param {Array.<string>} keys\n * @param {number}         _minValue\n * @param {number|string}  _maxValue\n * @param {Array.<number>} range\n * @returns {Function}\n */\nexport var getGroupedScale = function getGroupedScale(data, keys, _minValue, _maxValue, range) {\n    var allValues = data.reduce(function (acc, entry) {\n        return [].concat(acc, keys.map(function (k) {\n            return entry[k];\n        }));\n    }, []);\n\n    var maxValue = _maxValue;\n    if (maxValue === 'auto') {\n        maxValue = _max(allValues);\n    }\n\n    var minValue = _minValue;\n    if (minValue === 'auto') {\n        minValue = _min(allValues);\n        if (minValue > 0) minValue = 0;\n    }\n\n    return scaleLinear().rangeRound(range).domain([minValue, maxValue]);\n};\n\n/**\n * Generates x/y scales & bars for vertical grouped bar chart.\n *\n * @param {Array.<Object>} data\n * @param {Function}       getIndex\n * @param {Array.<string>} keys\n * @param {number}         minValue\n * @param {number}         maxValue\n * @param {boolean}        reverse\n * @param {number}         width\n * @param {number}         height\n * @param {Function}       getColor\n * @param {number}         [padding=0]\n * @param {number}         [innerPadding=0]\n * @return {{ xScale: Function, yScale: Function, bars: Array.<Object> }}\n */\nexport var generateVerticalGroupedBars = function generateVerticalGroupedBars(_ref) {\n    var data = _ref.data,\n        getIndex = _ref.getIndex,\n        keys = _ref.keys,\n        minValue = _ref.minValue,\n        maxValue = _ref.maxValue,\n        reverse = _ref.reverse,\n        width = _ref.width,\n        height = _ref.height,\n        getColor = _ref.getColor,\n        _ref$padding = _ref.padding,\n        padding = _ref$padding === undefined ? 0 : _ref$padding,\n        _ref$innerPadding = _ref.innerPadding,\n        innerPadding = _ref$innerPadding === undefined ? 0 : _ref$innerPadding;\n\n    var xScale = getIndexedScale(data, getIndex, [0, width], padding);\n    var yRange = reverse ? [0, height] : [height, 0];\n    var yScale = getGroupedScale(data, keys, minValue, maxValue, yRange);\n\n    var barWidth = (xScale.bandwidth() - innerPadding * (keys.length - 1)) / keys.length;\n    var yRef = yScale(0);\n\n    var getY = function getY(d) {\n        return d > 0 ? yScale(d) : yRef;\n    };\n    var getHeight = function getHeight(d, y) {\n        return d > 0 ? yRef - y : yScale(d) - yRef;\n    };\n    if (reverse) {\n        getY = function getY(d) {\n            return d < 0 ? yScale(d) : yRef;\n        };\n        getHeight = function getHeight(d, y) {\n            return d < 0 ? yRef - y : yScale(d) - yRef;\n        };\n    }\n\n    var bars = [];\n    if (barWidth > 0) {\n        keys.forEach(function (key, i) {\n            _range(xScale.domain().length).forEach(function (index) {\n                var x = xScale(getIndex(data[index])) + barWidth * i + innerPadding * i;\n                var y = getY(data[index][key]);\n                var barHeight = getHeight(data[index][key], y);\n\n                if (barWidth > 0 && barHeight > 0) {\n                    var barData = {\n                        id: key,\n                        value: data[index][key],\n                        index: index,\n                        indexValue: getIndex(data[index]),\n                        data: data[index]\n                    };\n\n                    bars.push({\n                        key: key + '.' + barData.indexValue,\n                        data: barData,\n                        x: x,\n                        y: y,\n                        width: barWidth,\n                        height: barHeight,\n                        color: getColor(barData)\n                    });\n                }\n            });\n        });\n    }\n\n    return { xScale: xScale, yScale: yScale, bars: bars };\n};\n\n/**\n * Generates x/y scales & bars for horizontal grouped bar chart.\n *\n * @param {Array.<Object>} data\n * @param {Function}       getIndex\n * @param {Array.<string>} keys\n * @param {number}         minValue\n * @param {number}         maxValue\n * @param {boolean}        reverse\n * @param {number}         width\n * @param {number}         height\n * @param {Function}       getColor\n * @param {number}         [padding=0]\n * @param {number}         [innerPadding=0]\n * @return {{ xScale: Function, yScale: Function, bars: Array.<Object> }}\n */\nexport var generateHorizontalGroupedBars = function generateHorizontalGroupedBars(_ref2) {\n    var data = _ref2.data,\n        getIndex = _ref2.getIndex,\n        keys = _ref2.keys,\n        minValue = _ref2.minValue,\n        maxValue = _ref2.maxValue,\n        reverse = _ref2.reverse,\n        width = _ref2.width,\n        height = _ref2.height,\n        getColor = _ref2.getColor,\n        _ref2$padding = _ref2.padding,\n        padding = _ref2$padding === undefined ? 0 : _ref2$padding,\n        _ref2$innerPadding = _ref2.innerPadding,\n        innerPadding = _ref2$innerPadding === undefined ? 0 : _ref2$innerPadding;\n\n    var xRange = reverse ? [width, 0] : [0, width];\n    var xScale = getGroupedScale(data, keys, minValue, maxValue, xRange);\n    var yScale = getIndexedScale(data, getIndex, [height, 0], padding);\n\n    var barHeight = (yScale.bandwidth() - innerPadding * (keys.length - 1)) / keys.length;\n    var xRef = xScale(0);\n\n    var getX = function getX(d) {\n        return d > 0 ? xRef : xScale(d);\n    };\n    var getWidth = function getWidth(d, x) {\n        return d > 0 ? xScale(d) - xRef : xRef - x;\n    };\n    if (reverse) {\n        getX = function getX(d) {\n            return d < 0 ? xRef : xScale(d);\n        };\n        getWidth = function getWidth(d, x) {\n            return d < 0 ? xScale(d) - xRef : xRef - x;\n        };\n    }\n\n    var bars = [];\n    if (barHeight > 0) {\n        keys.forEach(function (key, i) {\n            _range(yScale.domain().length).forEach(function (index) {\n                var x = getX(data[index][key]);\n                var y = yScale(getIndex(data[index])) + barHeight * i + innerPadding * i;\n                var barWidth = getWidth(data[index][key], x);\n\n                if (barWidth > 0) {\n                    var barData = {\n                        id: key,\n                        value: data[index][key],\n                        index: index,\n                        indexValue: getIndex(data[index]),\n                        data: data[index]\n                    };\n\n                    bars.push({\n                        key: key + '.' + barData.indexValue,\n                        data: barData,\n                        x: x,\n                        y: y,\n                        width: barWidth,\n                        height: barHeight,\n                        color: getColor(barData)\n                    });\n                }\n            });\n        });\n    }\n\n    return { xScale: xScale, yScale: yScale, bars: bars };\n};\n\n/**\n * Generates x/y scales & bars for grouped bar chart.\n *\n * @param {Object} options\n * @return {{ xScale: Function, yScale: Function, bars: Array.<Object> }}\n */\nexport var generateGroupedBars = function generateGroupedBars(options) {\n    return options.layout === 'vertical' ? generateVerticalGroupedBars(options) : generateHorizontalGroupedBars(options);\n};"]},"metadata":{},"sourceType":"module"}