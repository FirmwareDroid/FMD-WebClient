{"ast":null,"code":"import _set from 'lodash/set';\nimport _get from 'lodash/get';\nimport _isEqual from 'lodash/isEqual';\nimport _pick from 'lodash/pick';\nimport _isPlainObject from 'lodash/isPlainObject';\nimport _isFunction from 'lodash/isFunction';\n/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nimport { gradientTypes, patternTypes } from '../components/defs';\nvar gradientKeys = Object.keys(gradientTypes);\nvar patternKeys = Object.keys(patternTypes);\n/**\n * Check a node matches given def predicate.\n *\n * @param {string|Function|Object} predicate\n * @param {Object}                 node\n * @param {string}                 [dataKey] - Optional path to access node data\n * @returns {boolean}\n */\n\nexport var isMatchingDef = function isMatchingDef(predicate, node, dataKey) {\n  if (predicate === '*') {\n    return true;\n  } else if (_isFunction(predicate)) {\n    return predicate(node);\n  } else if (_isPlainObject(predicate)) {\n    var data = dataKey ? _get(node, dataKey) : node;\n    return _isEqual(_pick(data, Object.keys(predicate)), predicate);\n  }\n\n  return false;\n};\n/**\n * Compute SVG defs.\n *\n * @param {Array.<Object>} defs               - Base SVG defs configs\n * @param {Array.<Object>} nodes              - Data nodes to apply defs on\n * @param {Array.<Object>} rules              - Rules used to conditionally apply defs on data nodes\n * @param {string}         [dataKey]          - Path to node data, used for rule object query based predicate\n * @param {string}         [colorKey='color'] - Node color path, required when inheritance is involved\n * @param {string}         [targetKey='fill'] - Node target property to apply def ID on\n * @returns {Array}\n */\n\nexport var bindDefs = function bindDefs(defs, nodes, rules) {\n  var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n      dataKey = _ref.dataKey,\n      _ref$colorKey = _ref.colorKey,\n      colorKey = _ref$colorKey === undefined ? 'color' : _ref$colorKey,\n      _ref$targetKey = _ref.targetKey,\n      targetKey = _ref$targetKey === undefined ? 'fill' : _ref$targetKey;\n\n  var boundDefs = []; // will hold generated variation ids,\n  // to avoid generating multiple identical defs\n\n  var generatedIds = {};\n\n  if (defs.length && nodes.length) {\n    // first, add base defs\n    boundDefs = [].concat(defs);\n    nodes.forEach(function (node) {\n      var _loop = function _loop(i) {\n        var _rules$i = rules[i],\n            id = _rules$i.id,\n            match = _rules$i.match;\n\n        if (isMatchingDef(match, node, dataKey)) {\n          var def = defs.find(function (_ref2) {\n            var defId = _ref2.id;\n            return defId === id;\n          });\n\n          if (def) {\n            if (patternKeys.includes(def.type)) {\n              if (def.background === 'inherit' || def.color === 'inherit') {\n                var nodeColor = _get(node, colorKey);\n\n                var background = def.background;\n                var color = def.color;\n                var inheritedId = id;\n\n                if (def.background === 'inherit') {\n                  inheritedId = inheritedId + '.bg.' + nodeColor;\n                  background = nodeColor;\n                }\n\n                if (def.color === 'inherit') {\n                  inheritedId = inheritedId + '.fg.' + nodeColor;\n                  color = nodeColor;\n                }\n\n                _set(node, targetKey, 'url(#' + inheritedId + ')');\n\n                if (!generatedIds[inheritedId]) {\n                  boundDefs.push(_extends({}, def, {\n                    id: inheritedId,\n                    background: background,\n                    color: color\n                  }));\n                  generatedIds[inheritedId] = 1;\n                }\n              } else {\n                // do not generate new def as there's no inheritance involved\n                _set(node, targetKey, 'url(#' + id + ')');\n              }\n            } else if (gradientKeys.includes(def.type)) {\n              var allColors = def.colors.map(function (_ref3) {\n                var color = _ref3.color;\n                return color;\n              });\n\n              if (allColors.includes('inherit')) {\n                var _nodeColor = _get(node, colorKey);\n\n                var _inheritedId = id;\n\n                var inheritedDef = _extends({}, def, {\n                  colors: def.colors.map(function (colorStop, i) {\n                    if (colorStop.color !== 'inherit') return colorStop;\n                    _inheritedId = _inheritedId + '.' + i + '.' + _nodeColor;\n                    return _extends({}, colorStop, {\n                      color: colorStop.color === 'inherit' ? _nodeColor : colorStop.color\n                    });\n                  })\n                });\n\n                inheritedDef.id = _inheritedId;\n\n                _set(node, targetKey, 'url(#' + _inheritedId + ')');\n\n                if (!generatedIds[_inheritedId]) {\n                  boundDefs.push(inheritedDef);\n                  generatedIds[_inheritedId] = 1;\n                }\n              } else {\n                // do not generate new def as there's no inheritance involved\n                _set(node, targetKey, 'url(#' + id + ')');\n              }\n            }\n          } // break loop on first match\n\n\n          return 'break';\n        }\n      };\n\n      for (var i = 0; i < rules.length; i++) {\n        var _ret = _loop(i);\n\n        if (_ret === 'break') break;\n      }\n    });\n  }\n\n  return boundDefs;\n};","map":{"version":3,"sources":["/Users/tom/Documents/MSE/zz_MasterThesis/06_FirmwareDroid/firmware-droid-client/node_modules/nivo/es/lib/defs.js"],"names":["_set","_get","_isEqual","_pick","_isPlainObject","_isFunction","_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","gradientTypes","patternTypes","gradientKeys","keys","patternKeys","isMatchingDef","predicate","node","dataKey","data","bindDefs","defs","nodes","rules","_ref","undefined","_ref$colorKey","colorKey","_ref$targetKey","targetKey","boundDefs","generatedIds","concat","forEach","_loop","_rules$i","id","match","def","find","_ref2","defId","includes","type","background","color","nodeColor","inheritedId","push","allColors","colors","map","_ref3","_nodeColor","_inheritedId","inheritedDef","colorStop","_ret"],"mappings":"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","sourcesContent":["import _set from 'lodash/set';\nimport _get from 'lodash/get';\nimport _isEqual from 'lodash/isEqual';\nimport _pick from 'lodash/pick';\nimport _isPlainObject from 'lodash/isPlainObject';\nimport _isFunction from 'lodash/isFunction'; /*\n                                              * This file is part of the nivo project.\n                                              *\n                                              * Copyright 2016-present, Raphaël Benitte.\n                                              *\n                                              * For the full copyright and license information, please view the LICENSE\n                                              * file that was distributed with this source code.\n                                              */\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nimport { gradientTypes, patternTypes } from '../components/defs';\n\nvar gradientKeys = Object.keys(gradientTypes);\nvar patternKeys = Object.keys(patternTypes);\n\n/**\n * Check a node matches given def predicate.\n *\n * @param {string|Function|Object} predicate\n * @param {Object}                 node\n * @param {string}                 [dataKey] - Optional path to access node data\n * @returns {boolean}\n */\nexport var isMatchingDef = function isMatchingDef(predicate, node, dataKey) {\n    if (predicate === '*') {\n        return true;\n    } else if (_isFunction(predicate)) {\n        return predicate(node);\n    } else if (_isPlainObject(predicate)) {\n        var data = dataKey ? _get(node, dataKey) : node;\n        return _isEqual(_pick(data, Object.keys(predicate)), predicate);\n    }\n\n    return false;\n};\n\n/**\n * Compute SVG defs.\n *\n * @param {Array.<Object>} defs               - Base SVG defs configs\n * @param {Array.<Object>} nodes              - Data nodes to apply defs on\n * @param {Array.<Object>} rules              - Rules used to conditionally apply defs on data nodes\n * @param {string}         [dataKey]          - Path to node data, used for rule object query based predicate\n * @param {string}         [colorKey='color'] - Node color path, required when inheritance is involved\n * @param {string}         [targetKey='fill'] - Node target property to apply def ID on\n * @returns {Array}\n */\nexport var bindDefs = function bindDefs(defs, nodes, rules) {\n    var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n        dataKey = _ref.dataKey,\n        _ref$colorKey = _ref.colorKey,\n        colorKey = _ref$colorKey === undefined ? 'color' : _ref$colorKey,\n        _ref$targetKey = _ref.targetKey,\n        targetKey = _ref$targetKey === undefined ? 'fill' : _ref$targetKey;\n\n    var boundDefs = [];\n\n    // will hold generated variation ids,\n    // to avoid generating multiple identical defs\n    var generatedIds = {};\n\n    if (defs.length && nodes.length) {\n        // first, add base defs\n        boundDefs = [].concat(defs);\n\n        nodes.forEach(function (node) {\n            var _loop = function _loop(i) {\n                var _rules$i = rules[i],\n                    id = _rules$i.id,\n                    match = _rules$i.match;\n\n                if (isMatchingDef(match, node, dataKey)) {\n                    var def = defs.find(function (_ref2) {\n                        var defId = _ref2.id;\n                        return defId === id;\n                    });\n                    if (def) {\n                        if (patternKeys.includes(def.type)) {\n                            if (def.background === 'inherit' || def.color === 'inherit') {\n                                var nodeColor = _get(node, colorKey);\n                                var background = def.background;\n                                var color = def.color;\n\n                                var inheritedId = id;\n                                if (def.background === 'inherit') {\n                                    inheritedId = inheritedId + '.bg.' + nodeColor;\n                                    background = nodeColor;\n                                }\n                                if (def.color === 'inherit') {\n                                    inheritedId = inheritedId + '.fg.' + nodeColor;\n                                    color = nodeColor;\n                                }\n\n                                _set(node, targetKey, 'url(#' + inheritedId + ')');\n                                if (!generatedIds[inheritedId]) {\n                                    boundDefs.push(_extends({}, def, {\n                                        id: inheritedId,\n                                        background: background,\n                                        color: color\n                                    }));\n                                    generatedIds[inheritedId] = 1;\n                                }\n                            } else {\n                                // do not generate new def as there's no inheritance involved\n                                _set(node, targetKey, 'url(#' + id + ')');\n                            }\n                        } else if (gradientKeys.includes(def.type)) {\n                            var allColors = def.colors.map(function (_ref3) {\n                                var color = _ref3.color;\n                                return color;\n                            });\n\n                            if (allColors.includes('inherit')) {\n                                var _nodeColor = _get(node, colorKey);\n\n                                var _inheritedId = id;\n                                var inheritedDef = _extends({}, def, {\n                                    colors: def.colors.map(function (colorStop, i) {\n                                        if (colorStop.color !== 'inherit') return colorStop;\n\n                                        _inheritedId = _inheritedId + '.' + i + '.' + _nodeColor;\n\n                                        return _extends({}, colorStop, {\n                                            color: colorStop.color === 'inherit' ? _nodeColor : colorStop.color\n                                        });\n                                    })\n                                });\n                                inheritedDef.id = _inheritedId;\n\n                                _set(node, targetKey, 'url(#' + _inheritedId + ')');\n                                if (!generatedIds[_inheritedId]) {\n                                    boundDefs.push(inheritedDef);\n                                    generatedIds[_inheritedId] = 1;\n                                }\n                            } else {\n                                // do not generate new def as there's no inheritance involved\n                                _set(node, targetKey, 'url(#' + id + ')');\n                            }\n                        }\n                    }\n\n                    // break loop on first match\n                    return 'break';\n                }\n            };\n\n            for (var i = 0; i < rules.length; i++) {\n                var _ret = _loop(i);\n\n                if (_ret === 'break') break;\n            }\n        });\n    }\n\n    return boundDefs;\n};"]},"metadata":{},"sourceType":"module"}